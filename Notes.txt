$$$1. spread operator syntax example: <Todo key={todo.id} {...todo}/> (in the TodoList.js file)

$$$2. Why use Array.map() rather than Array.forEach()?
Array.forEach doesn't do anything with the returned value inside the callback.
forEach itself always returns undefined, not an array.
On the other hand, Array.map() turns all the returned values into a new array which is exactly what we want!
Maps return value is the array of new values.

From the docs for forEach:
"forEach() executes the callback function once for each array element;
unlike map() or reduce() it always returns the value undefined and is not chainable.
The typical use case is to execute side effects at the end of a chain."

$$$3. Arrow functions only implicitly return when using the expression syntax with no curly braces.
The statements syntax with curly braces does require an explicit return statements.

To see an example - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions

$$$4. Question: why can't we just have this.handleSubmit on the button onClick event instead of having a form and then onSubmit?
Answer: Form tags are still an important thing to use, we're just switching up how we use it.
onClick limits how the user can submit the form.
People using the keyboard and clicking the enter key to submit the form will not able to.
They'll have to click the button.

Using the form tag with onSubmit opens up a wider range of options and accessibility enhancements.
I would not reccomend creating a form without a form tag.
It's use has evolved with the modern web.

$$$5. In test.js file, should we use ref or ReactDOM.findDOMNode()?
From Andrew:
We previously used "var form = ReactDOM.findDOMNode(...)" to target the form and simulate a submit action.
We don't need to do that here since we have refs defined on our input fields.
The refs point directly to the DOM nodes we want to simulate events on.
That means ReactDOM.findDOMNode(...) is not necessary.

I use jQuery in the tests to allow for more flexible querying of the components DOM.
You can 100% remove jQuery and use refs,
I just found it annoying to create all these refs that were only going to be used by my test file.

$$$6.
Remember, every time we run webpack we are generating a bundle.js file.
That bundle.js file contains all the JavaScript we need to run our app.
It has code we wrote, and it has 3rd party module code we've required.

In this scenario, I would only add the modules actually required on Heroku which would be express.
Express is used in server.js and is not bundled with our app.
Everything else gets bundled via webpack and pushed to Heroku.

In lecture 137 we switch the process around and run webpack on the server to see how that would work.
In that case we would need uuid and our other modules under dependencies, not devDependencies.

$$$7. Why use uuid rather than doing things like this - "id: this.state.todos.length + 1"
I would just be careful when it comes to deleting todos.
If I add a todo to an empty array, its id will be 1 (length of 0 plus 1).
Now lets say I add 4 more, so the ids 1, 2, 3, 4, and 5 are taken.
If I remove the todo with an id of 2 and try to add another, the id generated is going to be 5 which already exists.
I'm assuming you're using the same exact code as Spencer was.

I prefer to use node-uuid to generate cryptographically strong ids.

$$$8.
Regular functions using the function keyword create a new this binding.
You can keep the parent this binding by defining an arrow function!
Arrow functions to not create a new this binding

$$$9. How would you store images, videos, etc that is not easily converted into string be stored? Like user profile picture.
Answer: There are a few way you can do this.
I would reccomend using a service built for files like AWS S3 or the new Firebase storage features.
When you're working with videos or images in your app (with or without redux)
you should try to pass around ID as opposed to the entire contents of the file.
If I want someone to be able to upload a file, I would made a call to the Firebase/AWS API to upload the file.
I would then get a unique ID back, and that's the string I would store in my database or in localStorage.

$$$10. localStorage does NOT persist between different browsers

$$$11. beforeEach method runs before every test defined in it() method

// beforeEach "a"

// it "a" - will have beforeEach "a" executed before it runs

// describe some group

    // beforeEach "b"

    // it "b" - will have beforeEach "a" and "b" executes before it runs

$$$12. expect assertions toBe() vs toEqual()
toBe() compares the value using the tripe equals like so: 1 === 1
toEqual() compares values using the is-equal library.
This allows us to check if two arrays or objects are the same.

Try running the following statements. They are all going to result in false.

{} === {};  // false
[1] === [1];  // false

JavaScript is checking if they are the same object, not two objects/arrays with the same values.
The is-equal library will compare for values which we want!

$$$13. Keep css attributes in alpha-betical order; make it eary to scan

$$$14. SCSS topic - Naming variables
Hey Andrew,
I've noticed that you tend to name variables that define colors with the color name.

$grey: #333;
$light-grey: #666;

This leads to situations where in order to quickly adapt to clients' or leads' requests
we resort to change the value of the variables while maintaining the variable names.
So that we might have a variable $grey that in fact set a color that is totally different than the original.

$grey: teal;

On the other hand, if you will decide to change the variable name from $grey to $teal,
you will de facto defy the very reason you used a variable in the first place
because you will have to go throw all your files and change all instances of $grey into $teal.

A better approach is to create variables with a functional name.

$background-color: #333;

If so, it will not matter if we have to dramatically change the color of the variable.
Whatever color, it will always be the background color.

A similar approach can be used for lightening up a color.
Instead of $light-grey, I'd prefer the following approach.

$background-color-alt: lighten($background-color, 10%);

That allows for a structure that's easier to manipulate in future,
might you have to editing its fundamental values drastically.

$$$15. Open this link if you want to move to bootstrap:
https://www.udemy.com/the-complete-react-web-app-developer-course/learn/v4/questions/1873574

$$$16. SCSS Partials
You can create partial Sass files that contain little snippets of CSS that you can include in other Sass files.
This is a great way to modularize your CSS and help keep things easier to maintain.
A partial is simply a Sass file named with a leading underscore.
You might name it something like _partial.scss.
The underscore lets Sass know that the file is only a partial file and that it should not be generated into a CSS file.
Sass partials are used with the @import directive.

$$$17. .toBe() vs .toEqual()?
.toBe() would be a little faster as it uses === and .toEqual() uses a 3rd party library called is-equal.
I've always preferred toEqual because I don't have to think about what values I'm passing in (object or boolean).
I can pass in my values and know it'll work as expected.

$$$18. Actions and reducers
An action only returns a description of what is to be done,
while a reducer takes that description and calculates
what the next state should be after applying the action.

The action object doesn't define the state.
It defines the changes that should be made.
This might include nothing but a type property.
It would be unmanageable if every action needed to compute the entire state.

The reducer (or reducers) takes the current state and the action.
It uses these two to compute and return the new state.
If we removed reducers, we would still need to compute the state.
Reducers are a solution to that problem.

$$$19. There is really no reason to deep freeze primitive values (boolean, number) or strings
as by their very nature they are immutable; These don't need to be passed through deep-freeze-strict.
This is done out of a habit to freeze everything getting passed into the reducer.

Only Objects (which would include arrays) are passed by reference.

$$$20. Question: Is there a difference between Deep Freeze package and Object.freeze() function?
Answer: Deep Freeze will recursively freeze all nested functions and objects.
Object.freeze only freezes top-level properties. For example:

var user = {
    name: 'Andrew',
    age: {
        num: 25
    }
};
var frozenUser = Object.freeze(user);

In the above example, I would not be able to update frozenUser.name
I would however be able to update frozenUser.age.num without any problems.
Deep Freeze would not allow someone to update frozenUser.age.num

$$$21. Both spread operator and Object.assign() are shallow copy.
Link for deep copy vs. shallow copy - https://www.cs.utexas.edu/~scottm/cs307/handouts/deepCopying.htm
Code example to find out:
let origOne = {
  user: {
    name: "Andrew"
  }
}
let newOne = {};
Object.assign(newOne, origOne);
newOne.user.name = "Mike";
console.log(origOne); // Will print "Mike"


let origTwo = {
  user: {
    name: "Andrew"
  }
}
let newTwo = { ...origTwo };
newTwo.user.name = "Mike";
console.log(origTwo); // Will print "Mike"

$$$22. Modern browsers are adding these features to their JavaScript engines.
The reason we use babel is to allow our web apps to run on older browsers that don't support them. 
Babel also allows us to use JSX which is a language extension.
